## 2.13 프로퍼티(Properties)

프로퍼티는 속성값을 가져오거나 설정하는 과정에서 사소한 연산이나 논리를 수행해야 할 때 사용할 수 있다.  
프로퍼티의 구현 방식은 일반적인 속성의 접근 방식과 동일한 기대치를 충족해야하는데, 즉 연산 비용(cheap)이 적고,직관적이며,예측 가능해야한다.

### 2.13.1 정의

속성은 메서드 호출을 감싸서 속성처럼 접근하고 설정할 수 있도록 하는 방법이다.

### 2.13.2 장점

• 속성 접근 및 할당 API를 제공하여 getter 및 setter 메서드 호출을 대체할 수 있다.  
• 속성을 읽기 전용으로 만들 수 있다.  
• 필요할 때만 계산을 수행할 수 있다.  
• 클래스 내부 구현이 변경되더라도, 클래스 사용자에게 제공되는 공개 API(public interface)를 유지할 수 있다.

### 2.13.3 단점

• 연산자 오버로딩처럼 예상치 못한 부작용(side effects)을 유발할 수 있다.  
• 서브클래스에서 이해하기 어려울 수 있다.

### 2.13.4 권장 사항

프로퍼티는 사용할 수 있지만, 연산자 오버로딩처럼 반드시 필요한 경우에만 사용해야 하며, 일반적인 속성의 접근 방식과 동일한 기대치를 충족해야 한다.  
그렇지 않을 경우, getter 및 setter 규칙을 따르는 것이 좋다.

예를 들어, 내부 속성을 단순히 가져오고 설정하는 역할만 하는 프로퍼티는 허용되지 않는다.  
이는 별다른 연산이 수행되지 않으므로 불필요한 프로퍼티이며, 대신 속성을 공개(public) 속성으로 선언하는 것이 적절하다.  
반면, 프로퍼티를 통해 속성 접근을 제어하거나 _간단한_ 계산이 필요할 경우에는 프로퍼티를 사용하는 것이 허용된다.  
이 경우, 로직이 단순하고 예측 가능하다.

프로퍼티는 `@property` 데코레이터(decorator)를 사용하여 생성해야 한다.  
수동으로 프로퍼티 디스크립터(property descriptor)를 구현하는 것은 고급 기능(advanced feature)으로 간주된다.

프로퍼티를 상속하면 예상과 다르게 동작할 수 있다.  
특히, 서브클래스에서 재정의되거나 확장될 가능성이 있는 연산을 프로퍼티로 구현하지 않아야 한다.
